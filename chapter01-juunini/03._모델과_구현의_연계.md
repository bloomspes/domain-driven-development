# 03. 모델과 구현의 연계

## 요약

- 모델은 코드와 동떨어진 개념이 아니다.
- 분석, 모델, 설계, 코드 모든게 연결되어야 한다. 그에 대한 책임도 모두 연결된다.
- 시니어와 주니어를 구분짓고 아키텍트와 코더를 구분한다는 명목으로 업무를 분리시키지 마라.

## 밑줄 친 부분

- 모델에 온갖 정성을 아낌없이 쏟아붓더라도 설계가 올바르다는 것을 보장할 수는 없는데, 이는 모델과 코드가 엄연히 다른 것이기 때문이다.
- 분석 모델은 설계상의 쟁점들을 염두에 두고 만들어진 것이 아니라서 모델과 설계의 연결을 분석 모델로 진행한다는 것은 매우 비현실적일 가능성이 높다.
- 설계의 기반이 되는 개념이 부족한 소프트웨어는 기껏해야 해당 소프트웨어의 행위를 설명하지 못한 채 그저 유익한 일을 수행하는 매커니즘 정도밖에 되지 않는다.
- 설계 혹은 설계의 주된 부분이 도메인 모델과 대응하지 않는다면 그 모델은 그다지 가치가 없으며 소프트웨어의 정확함도 의심스러워진다.
- 분석은 도메인의 근본적인 개념을 알기 쉽고 표현력 있는 방식으로 포착해야한다.
- 설계에서는 대상 배포 환경에서 효율적으로 수행되고 애플리케이션에서 다뤄야 할 문제를 올바르게 해결해 줄 수 있는 구성요소를 기술해야 하며, 이러한 구성요소는 프로젝트에서 사용중인 프로그래밍 도구로 구현할 수 있어야 한다.
- 소프트웨어 시스템의 일부를 설계할 때는 도메인 모델을 있는 그대로 반영해서 설계와 모델의 대응을 분명하게 하라.
- 모델은 실제적인 구현을 위해 정성스럽게 만들어져야 한다.
- 객체 설계에서의 진정한 도약은 코드가 모델의 개념을 포현할 때 나온다.
- 분석과 모델링, 설계, 프로그래밍에 대한 책임을 지나치게 구분하는 것은 MODEL-DRIVEN DESIGN과 상충한다.
- 고도로 숙련된 엔지니어는 설계를, 덜 숙련된 노동자는 제품을 조립한다는 것 ... 많은 프로젝트를 엉망으로 만들었다.
- 분석과 모델링, 설계, 프로그래밍에 대한 책임을 지나치게 구분하는 것은 MODEL-DRIVEN DESIGN과 상충한다.
- 개발자들은 상아탑에만 머물러 있는 아키텍트의 지시를 받는 위험을 더는 감수할 수 없었다.
- 코드를 작성하는 사람이 모델에 책임을 느끼지 못하거나 애플리케이션을 대상으로 모델이 동작하게 만드는 법을 모른다면 그 모델은 소프트웨어와 무관해진다.
- 코드를 변경하는 것이 곧 모델의 변경에 해당한다. 누가 좋아하건 말건 프로그래머가 곧 모델러다. 그러므로 프로그래머가 훌륭한 모델링 업무를 할 수 있게 프로젝트를 구성하는 것이 바람직하다.

## 시작할 때 나오는 사연

- 분석가가 작성한 큰 벽 전체를 덮고 있는 전체 클래스 다이어그램.
- 각 객체를 자연스럽게 구분짓는 경계가 거의 없었다.
- 이 다이어그램에 있는 정보로는 애플리케이션 코드와 설계에 어떠한 통찰력도 줄 수 없었다.
- 설계에 그것을 포함할 수 없을 것이라 판단되어 결국 개발자들은 즉흥적으로 설계를 만들어 나갔고, 클래스 다이어그램은 아무런 의미가 없었다.
- 결국 주먹구구식으로 완결되었고, 이후에 JAVA로 다시 구현하는 프로젝트를 진행했지만, 결국 비슷하게 비대하고 유지보수가 안되는 결과물이 나왔다.
