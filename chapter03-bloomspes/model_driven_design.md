# MODEL DRIVEN DESIGN

모델과 코드간의 연결이 긴밀해야 한다.

> 프로젝트에 도메인 모델은 있었지만, 동작하는 소프트웨어를 개발하는데 직접적으로 도움을 주지 않는 한 종이에 기록된 모델이 무슨 의미가 있겠는가?

`분석 모델(Analysis model)`을 사용해서 프로젝트를 설계하는 과정에서 쉽게 발생할 수 있는 오류들을 지적하고 있다. 

요지는 간단하다. 분석 모델과 설계는 통합된 것이 아닌 각각 분리된 것으로 보는 관점이기에 그렇다. 책에서는 아래와 같이 모델 추상화 과정이 실패하는 이유에 대해 설명하고 있다.

1. 설계와 뚜렷하게 구분되는 점이 업무 도메인을 분석한 결과물 이기 때문이다.
2. 그러므로 도메인을 이해하기 위한 수단으로 사용하는 것에 가깝다.
3. 순수하게 도메인 자체를 분석한 결과물 이므로 설계상에서 논의 되어야 할 부분이 제외될 수 밖에 없다.
4. 그런 점 때문에 소프트웨어 개발자가 도메인 모델을 추상화하는 과정에서 어려움을 겪는다.

책을 읽다가 의미가 모호한 부분이 있다면, 그 전후 단락을 함께 읽으면서 이해를 할 수 있다.

> MODEL-DRIVEN DESIGN에서는 양쪽 모두의 목적을 달성하는 단일 모델을 찾기위해 분석 모델과 설계를 나누는 이분법은 채택하지 않는다. 순수하게 **기술적인 쟁점**은 배제함으로써 설계상의 각 객체는 **모델에서 기술한 개념적 역할**을 수행하게 된다. 이렇게 되면 선택한 모델의 부담이 더 커지는데, 이는 **해당 모델이 아주 상이한 두 가지 목표를 달성해야만 하기 때문이다**.

바로 아래 단락에서 내용의 실마리를 찾을 수 있었다.

> **도메인을 추상화하는 방법**과 **애플리케이션의 문제를 해결할 수 있는 설계방법**은 언제나 여러가지가 있다.

여기까지 읽으면 도메인 모델이 달성해야 하는 두 가지 목표에 대해 이해가 가능하다.

> 모델이 구현에 대해 비현실적으로 보인다면 새로운 모델을 찾아내야만 한다. 모델이 도메인의 핵심 개념을 충실하게 표현하지 않을때도 새로운 모델을 찾아야만 한다. 그래야만 모델링과 설계 프로세스가 단 하나의 반복 고리를 형성할 수 있다.

여기까지 읽는다면, 도메인 모델을 사용해서 설계 프로세스를 어떻게 이터레이션으로 가져갈 수 있을지 대략적인 컨셉을 잡을 수 있겠다고 이해했다.

### (예제) 기계적인 설계 VS 모델 주도적인 설계

PCB 레이아웃 도구를 설계하는 과정을 예시로 든다.
지식 탐구과정으로 모델 추상화를 하지 않은 설계에서는 코드가 실제로 필요한 일에 관여하는 부분이 상당히 적다. 단순히 네트 파일을 추가하고 파일을 읽고 찾는데에 지나지 않는다.  
반면, `모델 주도 설계` 에서는 네트와 버스가 함께 작업을 수행하고 있고 규칙이 보조적인 업무를 수행하면서 코드가 요구사항을 충분히 반영하고 있다.

```java
class Net extends AbstractNet {
    private Bus bus;

    Set assignedRules() {
        //..
    }
}

```

```java
Set assignedRules() {
    Set result = new HashSet();
    result.addAll(super.assignedRules());
    result.addAll(bus.assignedRules());
    return result;
}
```

이렇게 네트와 버스가 각각 추상 클래스를 바라보게 하고 요구사항을 외부로부터 가져온다면, 요구사항의 수가 늘어나도 테스트는 얼마든지 하기 쉬운 형태로 설계가 변형될 수 있다.

### Hands-on Modeler

핸즈온 모델러는 소프트웨어 개발자를 의미함을 알 수 있다.
이 장에서 논의한 모든 내용의 결론은 기능이 풍부한 소프트웨어를 설계하는 점을 알 수 있다.

> HANDS-ON MODELER가 필요하다고 해서 팀원들이 전문화된 역할을 맡을 수 없다는 의미는 아니다. XP를 비롯한 모든 애자일 프로세스에서는 팀원의 역할을 정의하면 그 밖의 비공식적인 분업화가 자연스럽게 이뤄지곤 한다. 문제는 MODEL-DRIVEN DESIGN내에서 서로 긴밀하게 연결된 모델링과 구현이라는 두가지 과업을 분리하는 데서 나타난다.

> 코드를 변경하는 책임이 있는 모든 이들은 코드를 통해 모델을 표현하는 법을 반드시 배워야 한다.

